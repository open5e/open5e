{"version":3,"file":"Item.js","sourceRoot":"","sources":["../../../../src/client/Item/Item.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../../ClientContext\";\nimport {\n  createDocumentUri,\n  getIdFromLink,\n  getPathFromLink,\n  isItemResourceValid,\n  ResourceType,\n  StatusCodes,\n} from \"../../common\";\nimport { PartitionKey } from \"../../documents\";\nimport { extractPartitionKey, undefinedPartitionKey } from \"../../extractPartitionKey\";\nimport { RequestOptions, Response } from \"../../request\";\nimport { PatchRequestBody } from \"../../utils/patch\";\nimport { Container } from \"../Container\";\nimport { Resource } from \"../Resource\";\nimport { ItemDefinition } from \"./ItemDefinition\";\nimport { ItemResponse } from \"./ItemResponse\";\n\n/**\n * Used to perform operations on a specific item.\n *\n * @see {@link Items} for operations on all items; see `container.items`.\n */\nexport class Item {\n  private partitionKey: PartitionKey;\n  /**\n   * Returns a reference URL to the resource. Used for linking in Permissions.\n   */\n  public get url(): string {\n    return createDocumentUri(this.container.database.id, this.container.id, this.id);\n  }\n\n  /**\n   * @hidden\n   * @param container - The parent {@link Container}.\n   * @param id - The id of the given {@link Item}.\n   * @param partitionKey - The primary key of the given {@link Item} (only for partitioned containers).\n   */\n  constructor(\n    public readonly container: Container,\n    public readonly id: string,\n    partitionKey: PartitionKey,\n    private readonly clientContext: ClientContext\n  ) {\n    this.partitionKey = partitionKey;\n  }\n\n  /**\n   * Read the item's definition.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   * If the type, T, is a class, it won't pass `typeof` comparisons, because it won't have a match prototype.\n   * It's recommended to only use interfaces.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param options - Additional options for the request\n   *\n   * @example Using custom type for response\n   * ```typescript\n   * interface TodoItem {\n   *   title: string;\n   *   done: bool;\n   *   id: string;\n   * }\n   *\n   * let item: TodoItem;\n   * ({body: item} = await item.read<TodoItem>());\n   * ```\n   */\n  public async read<T extends ItemDefinition = any>(\n    options: RequestOptions = {}\n  ): Promise<ItemResponse<T>> {\n    if (this.partitionKey === undefined) {\n      const { resource: partitionKeyDefinition } =\n        await this.container.readPartitionKeyDefinition();\n      this.partitionKey = undefinedPartitionKey(partitionKeyDefinition);\n    }\n\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n    let response: Response<T & Resource>;\n    try {\n      response = await this.clientContext.read<T>({\n        path,\n        resourceType: ResourceType.item,\n        resourceId: id,\n        options,\n        partitionKey: this.partitionKey,\n      });\n    } catch (error: any) {\n      if (error.code !== StatusCodes.NotFound) {\n        throw error;\n      }\n      response = error;\n    }\n\n    return new ItemResponse(\n      response.result,\n      response.headers,\n      response.code,\n      response.substatus,\n      this\n    );\n  }\n\n  /**\n   * Replace the item's definition.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - The definition to replace the existing {@link Item}'s definition with.\n   * @param options - Additional options for the request\n   */\n  public replace(\n    body: ItemDefinition,\n    options?: RequestOptions\n  ): Promise<ItemResponse<ItemDefinition>>;\n  /**\n   * Replace the item's definition.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * There is no set schema for JSON items. They may contain any number of custom properties.\n   *\n   * @param body - The definition to replace the existing {@link Item}'s definition with.\n   * @param options - Additional options for the request\n   */\n  public replace<T extends ItemDefinition>(\n    body: T,\n    options?: RequestOptions\n  ): Promise<ItemResponse<T>>;\n  public async replace<T extends ItemDefinition>(\n    body: T,\n    options: RequestOptions = {}\n  ): Promise<ItemResponse<T>> {\n    if (this.partitionKey === undefined) {\n      const { resource: partitionKeyDefinition } =\n        await this.container.readPartitionKeyDefinition();\n      this.partitionKey = extractPartitionKey(body, partitionKeyDefinition);\n    }\n\n    const err = {};\n    if (!isItemResourceValid(body, err)) {\n      throw err;\n    }\n\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n\n    const response = await this.clientContext.replace<T>({\n      body,\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      options,\n      partitionKey: this.partitionKey,\n    });\n    return new ItemResponse(\n      response.result,\n      response.headers,\n      response.code,\n      response.substatus,\n      this\n    );\n  }\n\n  /**\n   * Delete the item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * @param options - Additional options for the request\n   */\n  public async delete<T extends ItemDefinition = any>(\n    options: RequestOptions = {}\n  ): Promise<ItemResponse<T>> {\n    if (this.partitionKey === undefined) {\n      const { resource: partitionKeyDefinition } =\n        await this.container.readPartitionKeyDefinition();\n      this.partitionKey = undefinedPartitionKey(partitionKeyDefinition);\n    }\n\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n\n    const response = await this.clientContext.delete<T>({\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      options,\n      partitionKey: this.partitionKey,\n    });\n    return new ItemResponse(\n      response.result,\n      response.headers,\n      response.code,\n      response.substatus,\n      this\n    );\n  }\n\n  /**\n   * Perform a JSONPatch on the item.\n   *\n   * Any provided type, T, is not necessarily enforced by the SDK.\n   * You may get more or less properties and it's up to your logic to enforce it.\n   *\n   * @param options - Additional options for the request\n   */\n  public async patch<T extends ItemDefinition = any>(\n    body: PatchRequestBody,\n    options: RequestOptions = {}\n  ): Promise<ItemResponse<T>> {\n    if (this.partitionKey === undefined) {\n      const { resource: partitionKeyDefinition } =\n        await this.container.readPartitionKeyDefinition();\n      this.partitionKey = extractPartitionKey(body, partitionKeyDefinition);\n    }\n\n    const path = getPathFromLink(this.url);\n    const id = getIdFromLink(this.url);\n\n    const response = await this.clientContext.patch<T>({\n      body,\n      path,\n      resourceType: ResourceType.item,\n      resourceId: id,\n      options,\n      partitionKey: this.partitionKey,\n    });\n    return new ItemResponse(\n      response.result,\n      response.headers,\n      response.code,\n      response.substatus,\n      this\n    );\n  }\n}\n"]}