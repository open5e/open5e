{"version":3,"file":"number.js","sourceRoot":"","sources":["../../../../../src/utils/hashing/encoding/number.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport JSBI from \"jsbi\";\nimport { BytePrefix } from \"./prefix\";\n\nexport function writeNumberForBinaryEncodingJSBI(hash: number): Buffer {\n  let payload = encodeNumberAsUInt64JSBI(hash);\n  let outputStream = Buffer.from(BytePrefix.Number, \"hex\");\n  const firstChunk = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n\n  outputStream = Buffer.concat([outputStream, Buffer.from(firstChunk.toString(16), \"hex\")]);\n  payload = JSBI.asUintN(64, JSBI.leftShift(JSBI.BigInt(payload), JSBI.BigInt(0x8)));\n\n  let byteToWrite = JSBI.BigInt(0);\n  let firstIteration = false;\n  let shifted: JSBI;\n  let padded: string;\n\n  do {\n    if (!firstIteration) {\n      // we pad because after shifting because we will produce characters like \"f\" or similar,\n      // which cannot be encoded as hex in a buffer because they are invalid hex\n      // https://github.com/nodejs/node/issues/24491\n      padded = byteToWrite.toString(16).padStart(2, \"0\");\n      if (padded !== \"00\") {\n        outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n      }\n    } else {\n      firstIteration = false;\n    }\n\n    shifted = JSBI.asUintN(64, JSBI.signedRightShift(payload, JSBI.BigInt(56)));\n    byteToWrite = JSBI.asUintN(64, JSBI.bitwiseOr(shifted, JSBI.BigInt(0x01)));\n    payload = JSBI.asUintN(64, JSBI.leftShift(payload, JSBI.BigInt(7)));\n  } while (JSBI.notEqual(payload, JSBI.BigInt(0)));\n\n  const lastChunk = JSBI.asUintN(64, JSBI.bitwiseAnd(byteToWrite, JSBI.BigInt(0xfe)));\n  // we pad because after shifting because we will produce characters like \"f\" or similar,\n  // which cannot be encoded as hex in a buffer because they are invalid hex\n  // https://github.com/nodejs/node/issues/24491\n  padded = lastChunk.toString(16).padStart(2, \"0\");\n  if (padded !== \"00\") {\n    outputStream = Buffer.concat([outputStream, Buffer.from(padded, \"hex\")]);\n  }\n\n  return outputStream;\n}\n\nfunction encodeNumberAsUInt64JSBI(value: number): JSBI {\n  const rawValueBits = getRawBitsJSBI(value);\n  const mask = JSBI.BigInt(0x8000000000000000);\n  const returned =\n    rawValueBits < mask\n      ? JSBI.bitwiseXor(rawValueBits, mask)\n      : JSBI.add(JSBI.bitwiseNot(rawValueBits), JSBI.BigInt(1));\n  return returned;\n}\n\nexport function doubleToByteArrayJSBI(double: number): Buffer {\n  const output: Buffer = Buffer.alloc(8);\n  const lng = getRawBitsJSBI(double);\n  for (let i = 0; i < 8; i++) {\n    output[i] = JSBI.toNumber(\n      JSBI.bitwiseAnd(\n        JSBI.signedRightShift(lng, JSBI.multiply(JSBI.BigInt(i), JSBI.BigInt(8))),\n        JSBI.BigInt(0xff)\n      )\n    );\n  }\n  return output;\n}\n\nfunction getRawBitsJSBI(value: number): JSBI {\n  const view = new DataView(new ArrayBuffer(8));\n  view.setFloat64(0, value);\n  return JSBI.BigInt(`0x${buf2hex(view.buffer)}`);\n}\n\nfunction buf2hex(buffer: ArrayBuffer): string {\n  return Array.prototype.map\n    .call(new Uint8Array(buffer), (x: number) => (\"00\" + x.toString(16)).slice(-2))\n    .join(\"\");\n}\n"]}