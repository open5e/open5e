{"version":3,"file":"pipelinedQueryExecutionContext.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/pipelinedQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { ClientContext } from \"../ClientContext\";\nimport { Response, FeedOptions } from \"../request\";\nimport { PartitionedQueryExecutionInfo } from \"../request/ErrorResponse\";\nimport { CosmosHeaders } from \"./CosmosHeaders\";\nimport { OffsetLimitEndpointComponent } from \"./EndpointComponent/OffsetLimitEndpointComponent\";\nimport { OrderByEndpointComponent } from \"./EndpointComponent/OrderByEndpointComponent\";\nimport { OrderedDistinctEndpointComponent } from \"./EndpointComponent/OrderedDistinctEndpointComponent\";\nimport { UnorderedDistinctEndpointComponent } from \"./EndpointComponent/UnorderedDistinctEndpointComponent\";\nimport { GroupByEndpointComponent } from \"./EndpointComponent/GroupByEndpointComponent\";\nimport { ExecutionContext } from \"./ExecutionContext\";\nimport { getInitialHeader, mergeHeaders } from \"./headerUtils\";\nimport { OrderByQueryExecutionContext } from \"./orderByQueryExecutionContext\";\nimport { ParallelQueryExecutionContext } from \"./parallelQueryExecutionContext\";\nimport { GroupByValueEndpointComponent } from \"./EndpointComponent/GroupByValueEndpointComponent\";\nimport { SqlQuerySpec } from \"./SqlQuerySpec\";\n\n/** @hidden */\nexport class PipelinedQueryExecutionContext implements ExecutionContext {\n  private fetchBuffer: any[];\n  private fetchMoreRespHeaders: CosmosHeaders;\n  private endpoint: ExecutionContext;\n  private pageSize: number;\n  private static DEFAULT_PAGE_SIZE = 10;\n  constructor(\n    private clientContext: ClientContext,\n    private collectionLink: string,\n    private query: string | SqlQuerySpec,\n    private options: FeedOptions,\n    private partitionedQueryExecutionInfo: PartitionedQueryExecutionInfo\n  ) {\n    this.endpoint = null;\n    this.pageSize = options[\"maxItemCount\"];\n    if (this.pageSize === undefined) {\n      this.pageSize = PipelinedQueryExecutionContext.DEFAULT_PAGE_SIZE;\n    }\n\n    // Pick between parallel vs order by execution context\n    const sortOrders = partitionedQueryExecutionInfo.queryInfo.orderBy;\n    if (Array.isArray(sortOrders) && sortOrders.length > 0) {\n      // Need to wrap orderby execution context in endpoint component, since the data is nested as a \\\n      //      \"payload\" property.\n      this.endpoint = new OrderByEndpointComponent(\n        new OrderByQueryExecutionContext(\n          this.clientContext,\n          this.collectionLink,\n          this.query,\n          this.options,\n          this.partitionedQueryExecutionInfo\n        )\n      );\n    } else {\n      this.endpoint = new ParallelQueryExecutionContext(\n        this.clientContext,\n        this.collectionLink,\n        this.query,\n        this.options,\n        this.partitionedQueryExecutionInfo\n      );\n    }\n    if (\n      Object.keys(partitionedQueryExecutionInfo.queryInfo.groupByAliasToAggregateType).length > 0 ||\n      partitionedQueryExecutionInfo.queryInfo.aggregates.length > 0 ||\n      partitionedQueryExecutionInfo.queryInfo.groupByExpressions.length > 0\n    ) {\n      if (partitionedQueryExecutionInfo.queryInfo.hasSelectValue) {\n        this.endpoint = new GroupByValueEndpointComponent(\n          this.endpoint,\n          partitionedQueryExecutionInfo.queryInfo\n        );\n      } else {\n        this.endpoint = new GroupByEndpointComponent(\n          this.endpoint,\n          partitionedQueryExecutionInfo.queryInfo\n        );\n      }\n    }\n    // If top then add that to the pipeline. TOP N is effectively OFFSET 0 LIMIT N\n    const top = partitionedQueryExecutionInfo.queryInfo.top;\n    if (typeof top === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, 0, top);\n    }\n\n    // If offset+limit then add that to the pipeline\n    const limit = partitionedQueryExecutionInfo.queryInfo.limit;\n    const offset = partitionedQueryExecutionInfo.queryInfo.offset;\n    if (typeof limit === \"number\" && typeof offset === \"number\") {\n      this.endpoint = new OffsetLimitEndpointComponent(this.endpoint, offset, limit);\n    }\n\n    // If distinct then add that to the pipeline\n    const distinctType = partitionedQueryExecutionInfo.queryInfo.distinctType;\n    if (distinctType === \"Ordered\") {\n      this.endpoint = new OrderedDistinctEndpointComponent(this.endpoint);\n    }\n    if (distinctType === \"Unordered\") {\n      this.endpoint = new UnorderedDistinctEndpointComponent(this.endpoint);\n    }\n  }\n\n  public async nextItem(): Promise<Response<any>> {\n    return this.endpoint.nextItem();\n  }\n\n  // Removed callback here beacuse it wouldn't have ever worked...\n  public hasMoreResults(): boolean {\n    return this.endpoint.hasMoreResults();\n  }\n\n  public async fetchMore(): Promise<Response<any>> {\n    // if the wrapped endpoint has different implementation for fetchMore use that\n    // otherwise use the default implementation\n    if (typeof this.endpoint.fetchMore === \"function\") {\n      return this.endpoint.fetchMore();\n    } else {\n      this.fetchBuffer = [];\n      this.fetchMoreRespHeaders = getInitialHeader();\n      return this._fetchMoreImplementation();\n    }\n  }\n\n  private async _fetchMoreImplementation(): Promise<Response<any>> {\n    try {\n      const { result: item, headers } = await this.endpoint.nextItem();\n      mergeHeaders(this.fetchMoreRespHeaders, headers);\n      if (item === undefined) {\n        // no more results\n        if (this.fetchBuffer.length === 0) {\n          return {\n            result: undefined,\n            headers: this.fetchMoreRespHeaders,\n          };\n        } else {\n          // Just give what we have\n          const temp = this.fetchBuffer;\n          this.fetchBuffer = [];\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        }\n      } else {\n        // append the result\n        this.fetchBuffer.push(item);\n        if (this.fetchBuffer.length >= this.pageSize) {\n          // fetched enough results\n          const temp = this.fetchBuffer.slice(0, this.pageSize);\n          this.fetchBuffer = this.fetchBuffer.splice(this.pageSize);\n          return { result: temp, headers: this.fetchMoreRespHeaders };\n        } else {\n          // recursively fetch more\n          // TODO: is recursion a good idea?\n          return this._fetchMoreImplementation();\n        }\n      }\n    } catch (err: any) {\n      mergeHeaders(this.fetchMoreRespHeaders, err.headers);\n      err.headers = this.fetchMoreRespHeaders;\n      if (err) {\n        throw err;\n      }\n    }\n  }\n}\n"]}