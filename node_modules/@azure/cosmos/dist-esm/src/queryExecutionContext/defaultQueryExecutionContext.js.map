{"version":3,"file":"defaultQueryExecutionContext.js","sourceRoot":"","sources":["../../../src/queryExecutionContext/defaultQueryExecutionContext.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\nimport { AzureLogger, createClientLogger } from \"@azure/logger\";\nimport { Constants } from \"../common\";\nimport { ClientSideMetrics, QueryMetrics } from \"../queryMetrics\";\nimport { FeedOptions, Response } from \"../request\";\nimport { getInitialHeader } from \"./headerUtils\";\nimport { ExecutionContext } from \"./index\";\n\nconst logger: AzureLogger = createClientLogger(\"ClientContext\");\n/** @hidden */\nexport type FetchFunctionCallback = (options: FeedOptions) => Promise<Response<any>>;\n\n/** @hidden */\nenum STATES {\n  start = \"start\",\n  inProgress = \"inProgress\",\n  ended = \"ended\",\n}\n\n/** @hidden */\nexport class DefaultQueryExecutionContext implements ExecutionContext {\n  private static readonly STATES = STATES;\n  private resources: any[]; // TODO: any resources\n  private currentIndex: number;\n  private currentPartitionIndex: number;\n  private fetchFunctions: FetchFunctionCallback[];\n  private options: FeedOptions; // TODO: any options\n  public continuationToken: string; // TODO: any continuation\n  public get continuation(): string {\n    return this.continuationToken;\n  }\n  private state: STATES;\n  private nextFetchFunction: Promise<Response<any>>;\n  /**\n   * Provides the basic Query Execution Context.\n   * This wraps the internal logic query execution using provided fetch functions\n   *\n   * @param clientContext  - Is used to read the partitionKeyRanges for split proofing\n   * @param query          - A SQL query.\n   * @param options        - Represents the feed options.\n   * @param fetchFunctions - A function to retrieve each page of data.\n   *                          An array of functions may be used to query more than one partition.\n   * @hidden\n   */\n  constructor(\n    options: FeedOptions,\n    fetchFunctions: FetchFunctionCallback | FetchFunctionCallback[]\n  ) {\n    this.resources = [];\n    this.currentIndex = 0;\n    this.currentPartitionIndex = 0;\n    this.fetchFunctions = Array.isArray(fetchFunctions) ? fetchFunctions : [fetchFunctions];\n    this.options = options || {};\n    this.continuationToken = this.options.continuationToken || this.options.continuation || null;\n    this.state = DefaultQueryExecutionContext.STATES.start;\n  }\n\n  /**\n   * Execute a provided callback on the next element in the execution context.\n   */\n  public async nextItem(): Promise<Response<any>> {\n    ++this.currentIndex;\n    const response = await this.current();\n    return response;\n  }\n\n  /**\n   * Retrieve the current element on the execution context.\n   */\n  public async current(): Promise<Response<any>> {\n    if (this.currentIndex < this.resources.length) {\n      return {\n        result: this.resources[this.currentIndex],\n        headers: getInitialHeader(),\n      };\n    }\n\n    if (this._canFetchMore()) {\n      const { result: resources, headers } = await this.fetchMore();\n      this.resources = resources;\n      if (this.resources.length === 0) {\n        if (!this.continuationToken && this.currentPartitionIndex >= this.fetchFunctions.length) {\n          this.state = DefaultQueryExecutionContext.STATES.ended;\n          return { result: undefined, headers };\n        } else {\n          return this.current();\n        }\n      }\n      return { result: this.resources[this.currentIndex], headers };\n    } else {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      return { result: undefined, headers: getInitialHeader() };\n    }\n  }\n\n  /**\n   * Determine if there are still remaining resources to processs based on\n   * the value of the continuation token or the elements remaining on the current batch in the execution context.\n   *\n   * @returns true if there is other elements to process in the DefaultQueryExecutionContext.\n   */\n  public hasMoreResults(): boolean {\n    return (\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      this.continuationToken !== undefined ||\n      this.currentIndex < this.resources.length - 1 ||\n      this.currentPartitionIndex < this.fetchFunctions.length\n    );\n  }\n\n  /**\n   * Fetches the next batch of the feed and pass them as an array to a callback\n   */\n  public async fetchMore(): Promise<Response<any>> {\n    if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n      return { headers: getInitialHeader(), result: undefined };\n    }\n\n    // Keep to the original continuation and to restore the value after fetchFunction call\n    const originalContinuation = this.options.continuationToken || this.options.continuation;\n    this.options.continuationToken = this.continuationToken;\n\n    // Return undefined if there is no more results\n    if (this.currentPartitionIndex >= this.fetchFunctions.length) {\n      return { headers: getInitialHeader(), result: undefined };\n    }\n\n    let resources;\n    let responseHeaders;\n    try {\n      let p: Promise<Response<any>>;\n      if (this.nextFetchFunction !== undefined) {\n        logger.verbose(\"using prefetch\");\n        p = this.nextFetchFunction;\n        this.nextFetchFunction = undefined;\n      } else {\n        logger.verbose(\"using fresh fetch\");\n        p = this.fetchFunctions[this.currentPartitionIndex](this.options);\n      }\n      const response = await p;\n      resources = response.result;\n      responseHeaders = response.headers;\n\n      this.continuationToken = responseHeaders[Constants.HttpHeaders.Continuation];\n      if (!this.continuationToken) {\n        ++this.currentPartitionIndex;\n      }\n\n      if (this.options && this.options.bufferItems === true) {\n        const fetchFunction = this.fetchFunctions[this.currentPartitionIndex];\n        this.nextFetchFunction = fetchFunction\n          ? fetchFunction({ ...this.options, continuationToken: this.continuationToken })\n          : undefined;\n      }\n    } catch (err: any) {\n      this.state = DefaultQueryExecutionContext.STATES.ended;\n      // return callback(err, undefined, responseHeaders);\n      // TODO: Error and data being returned is an antipattern, this might broken\n      throw err;\n    }\n\n    this.state = DefaultQueryExecutionContext.STATES.inProgress;\n    this.currentIndex = 0;\n    this.options.continuationToken = originalContinuation;\n    this.options.continuation = originalContinuation;\n\n    // deserializing query metrics so that we aren't working with delimited strings in the rest of the code base\n    if (Constants.HttpHeaders.QueryMetrics in responseHeaders) {\n      const delimitedString = responseHeaders[Constants.HttpHeaders.QueryMetrics];\n      let queryMetrics = QueryMetrics.createFromDelimitedString(delimitedString);\n\n      // Add the request charge to the query metrics so that we can have per partition request charge.\n      if (Constants.HttpHeaders.RequestCharge in responseHeaders) {\n        const requestCharge = Number(responseHeaders[Constants.HttpHeaders.RequestCharge]) || 0;\n        queryMetrics = new QueryMetrics(\n          queryMetrics.retrievedDocumentCount,\n          queryMetrics.retrievedDocumentSize,\n          queryMetrics.outputDocumentCount,\n          queryMetrics.outputDocumentSize,\n          queryMetrics.indexHitDocumentCount,\n          queryMetrics.totalQueryExecutionTime,\n          queryMetrics.queryPreparationTimes,\n          queryMetrics.indexLookupTime,\n          queryMetrics.documentLoadTime,\n          queryMetrics.vmExecutionTime,\n          queryMetrics.runtimeExecutionTimes,\n          queryMetrics.documentWriteTime,\n          new ClientSideMetrics(requestCharge)\n        );\n      }\n\n      // Wraping query metrics in a object where the key is '0' just so single partition\n      // and partition queries have the same response schema\n      responseHeaders[Constants.HttpHeaders.QueryMetrics] = {};\n      responseHeaders[Constants.HttpHeaders.QueryMetrics][\"0\"] = queryMetrics;\n    }\n\n    return { result: resources, headers: responseHeaders };\n  }\n\n  private _canFetchMore(): boolean {\n    const res =\n      this.state === DefaultQueryExecutionContext.STATES.start ||\n      (this.continuationToken && this.state === DefaultQueryExecutionContext.STATES.inProgress) ||\n      (this.currentPartitionIndex < this.fetchFunctions.length &&\n        this.state === DefaultQueryExecutionContext.STATES.inProgress);\n    return res;\n  }\n}\n"]}