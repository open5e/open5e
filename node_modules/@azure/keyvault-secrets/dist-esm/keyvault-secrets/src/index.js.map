{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n/// <reference lib=\"esnext.asynciterable\" />\n\nimport { TokenCredential } from \"@azure/core-auth\";\n\nimport { bearerTokenAuthenticationPolicy } from \"@azure/core-rest-pipeline\";\n\nimport { logger } from \"./log\";\n\nimport \"@azure/core-paging\";\nimport { PageSettings, PagedAsyncIterableIterator } from \"@azure/core-paging\";\nimport { PollOperationState, PollerLike } from \"@azure/core-lro\";\nimport {\n  DeletedSecretBundle,\n  DeletionRecoveryLevel,\n  GetSecretsOptionalParams,\n  KnownDeletionRecoveryLevel,\n  SecretBundle,\n} from \"./generated/models\";\nimport { KeyVaultClient } from \"./generated/keyVaultClient\";\nimport { createChallengeCallbacks } from \"../../keyvault-common/src\";\n\nimport { DeleteSecretPoller } from \"./lro/delete/poller\";\nimport { RecoverDeletedSecretPoller } from \"./lro/recover/poller\";\n\nimport {\n  BackupSecretOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  DeletedSecret,\n  GetDeletedSecretOptions,\n  GetSecretOptions,\n  KeyVaultSecret,\n  LATEST_API_VERSION,\n  ListDeletedSecretsOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  PurgeDeletedSecretOptions,\n  RestoreSecretBackupOptions,\n  SecretClientOptions,\n  SecretPollerOptions,\n  SecretProperties,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n} from \"./secretsModels\";\nimport { KeyVaultSecretIdentifier, parseKeyVaultSecretIdentifier } from \"./identifier\";\nimport { getSecretFromSecretBundle } from \"./transformations\";\nimport { tracingClient } from \"./tracing\";\n\nexport {\n  SecretClientOptions,\n  DeletedSecret,\n  DeletionRecoveryLevel,\n  KnownDeletionRecoveryLevel,\n  GetSecretOptions,\n  GetDeletedSecretOptions,\n  PurgeDeletedSecretOptions,\n  BackupSecretOptions,\n  RestoreSecretBackupOptions,\n  ListPropertiesOfSecretVersionsOptions,\n  ListPropertiesOfSecretsOptions,\n  ListDeletedSecretsOptions,\n  PagedAsyncIterableIterator,\n  PageSettings,\n  KeyVaultSecretIdentifier,\n  parseKeyVaultSecretIdentifier,\n  PollerLike,\n  PollOperationState,\n  KeyVaultSecret,\n  SecretProperties,\n  SecretPollerOptions,\n  BeginDeleteSecretOptions,\n  BeginRecoverDeletedSecretOptions,\n  SetSecretOptions,\n  UpdateSecretPropertiesOptions,\n  logger,\n};\n\n/**\n * The SecretClient provides methods to manage {@link KeyVaultSecret} in\n * the Azure Key Vault. The client supports creating, retrieving, updating,\n * deleting, purging, backing up, restoring and listing KeyVaultSecrets. The\n * client also supports listing {@link DeletedSecret} for a soft-delete enabled Azure\n * Key Vault.\n */\nexport class SecretClient {\n  /**\n   * The base URL to the vault\n   */\n  public readonly vaultUrl: string;\n\n  /**\n   * A reference to the auto-generated KeyVault HTTP client.\n   */\n  private readonly client: KeyVaultClient;\n\n  /**\n   * Creates an instance of SecretClient.\n   *\n   * Example usage:\n   * ```ts\n   * import { SecretClient } from \"@azure/keyvault-secrets\";\n   * import { DefaultAzureCredential } from \"@azure/identity\";\n   *\n   * let vaultUrl = `https://<MY KEYVAULT HERE>.vault.azure.net`;\n   * let credentials = new DefaultAzureCredential();\n   *\n   * let client = new SecretClient(vaultUrl, credentials);\n   * ```\n   * @param vaultUrl - The base URL to the vault. You should validate that this URL references a valid Key Vault resource. See https://aka.ms/azsdk/blog/vault-uri for details.\n   * @param credential - An object that implements the `TokenCredential` interface used to authenticate requests to the service. Use the \\@azure/identity package to create a credential that suits your needs.\n   * @param pipelineOptions - Pipeline options used to configure Key Vault API requests.\n   *                          Omit this parameter to use the default pipeline configuration.\n   */\n  constructor(\n    vaultUrl: string,\n    credential: TokenCredential,\n    pipelineOptions: SecretClientOptions = {}\n  ) {\n    this.vaultUrl = vaultUrl;\n\n    const authPolicy = bearerTokenAuthenticationPolicy({\n      credential,\n      scopes: [],\n      challengeCallbacks: createChallengeCallbacks(pipelineOptions),\n    });\n\n    const internalPipelineOptions = {\n      ...pipelineOptions,\n      loggingOptions: {\n        logger: logger.info,\n        allowedHeaderNames: [\n          \"x-ms-keyvault-region\",\n          \"x-ms-keyvault-network-info\",\n          \"x-ms-keyvault-service-version\",\n        ],\n      },\n    };\n\n    this.client = new KeyVaultClient(\n      pipelineOptions.serviceVersion || LATEST_API_VERSION,\n      internalPipelineOptions\n    );\n    this.client.pipeline.addPolicy(authPolicy);\n  }\n\n  /**\n   * The setSecret method adds a secret or secret version to the Azure Key Vault. If the named secret\n   * already exists, Azure Key Vault creates a new version of that secret.\n   * This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   * ```\n   * Adds a secret in a specified key vault.\n   * @param secretName - The name of the secret.\n   * @param value - The value of the secret.\n   * @param options - The optional parameters.\n   */\n  public setSecret(\n    secretName: string,\n    value: string,\n    options: SetSecretOptions = {}\n  ): Promise<KeyVaultSecret> {\n    let unflattenedOptions = {};\n\n    if (options) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires,\n        },\n      };\n    }\n    return tracingClient.withSpan(\n      \"SecretClient.setSecret\",\n      unflattenedOptions,\n      async (updatedOptions) => {\n        const response = await this.client.setSecret(\n          this.vaultUrl,\n          secretName,\n          value,\n          updatedOptions\n        );\n        return getSecretFromSecretBundle(response);\n      }\n    );\n  }\n\n  /**\n   * Deletes a secret stored in Azure Key Vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is deleted.\n   *\n   * This operation requires the secrets/delete permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = deletePoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginDeleteSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await deletePoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * Deletes a secret from a specified key vault.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public async beginDeleteSecret(\n    name: string,\n    options: BeginDeleteSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<DeletedSecret>, DeletedSecret>> {\n    const poller = new DeleteSecretPoller({\n      name,\n      client: this.client,\n      vaultUrl: this.vaultUrl,\n      ...options,\n      operationOptions: options,\n    });\n    // This will initialize the poller's operation (the deletion of the secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * The updateSecret method changes specified attributes of an existing stored secret. Properties that\n   * are not specified in the request are left unchanged. The value of a secret itself cannot be\n   * changed. This operation requires the secrets/set permission.\n   *\n   * Example usage:\n   * ```ts\n   * let secretName = \"MySecretName\";\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(secretName);\n   * await client.updateSecretProperties(secretName, secret.properties.version, { enabled: false });\n   * ```\n   * Updates the attributes associated with a specified secret in a given key vault.\n   * @param secretName - The name of the secret.\n   * @param secretVersion - The version of the secret.\n   * @param options - The optional parameters.\n   */\n  public async updateSecretProperties(\n    secretName: string,\n    secretVersion: string,\n    options: UpdateSecretPropertiesOptions = {}\n  ): Promise<SecretProperties> {\n    let unflattenedOptions = {};\n    if (options) {\n      const { enabled, notBefore, expiresOn: expires, ...remainingOptions } = options;\n      unflattenedOptions = {\n        ...remainingOptions,\n        secretAttributes: {\n          enabled,\n          notBefore,\n          expires,\n        },\n      };\n    }\n\n    return tracingClient.withSpan(\n      \"SecretClient.updateSecretProperties\",\n      unflattenedOptions,\n      async (updatedOptions) => {\n        const response = await this.client.updateSecret(\n          this.vaultUrl,\n          secretName,\n          secretVersion,\n          updatedOptions\n        );\n        return getSecretFromSecretBundle(response).properties;\n      }\n    );\n  }\n\n  /**\n   * The getSecret method is applicable to any secret stored in Azure Key Vault. This operation requires\n   * the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let secret = await client.getSecret(\"MySecretName\");\n   * ```\n   * Get a specified secret from a given key vault.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public getSecret(secretName: string, options: GetSecretOptions = {}): Promise<KeyVaultSecret> {\n    return tracingClient.withSpan(\"SecretClient.getSecret\", options, async (updatedOptions) => {\n      const response = await this.client.getSecret(\n        this.vaultUrl,\n        secretName,\n        options && options.version ? options.version : \"\",\n        updatedOptions\n      );\n      return getSecretFromSecretBundle(response);\n    });\n  }\n\n  /**\n   * The getDeletedSecret method returns the specified deleted secret along with its attributes.\n   * This operation requires the secrets/get permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * await client.getDeletedSecret(\"MyDeletedSecret\");\n   * ```\n   * Gets the specified deleted secret.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public getDeletedSecret(\n    secretName: string,\n    options: GetDeletedSecretOptions = {}\n  ): Promise<DeletedSecret> {\n    return tracingClient.withSpan(\n      \"SecretClient.getDeletedSecret\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.getDeletedSecret(\n          this.vaultUrl,\n          secretName,\n          updatedOptions\n        );\n        return getSecretFromSecretBundle(response);\n      }\n    );\n  }\n\n  /**\n   * The purge deleted secret operation removes the secret permanently, without the possibility of\n   * recovery. This operation can only be enabled on a soft-delete enabled vault. This operation\n   * requires the secrets/purge permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   * await client.purgeDeletedSecret(\"MySecretName\");\n   * ```\n   * Permanently deletes the specified secret.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public purgeDeletedSecret(\n    secretName: string,\n    options: PurgeDeletedSecretOptions = {}\n  ): Promise<void> {\n    return tracingClient.withSpan(\n      \"SecretClient.purgeDeletedSecret\",\n      options,\n      async (updatedOptions) => {\n        await this.client.purgeDeletedSecret(this.vaultUrl, secretName, updatedOptions);\n      }\n    );\n  }\n\n  /**\n   * Recovers the deleted secret in the specified vault.\n   * This function returns a Long Running Operation poller that allows you to wait indefinitely until the secret is recovered.\n   *\n   * This operation requires the secrets/recover permission.\n   *\n   * Example usage:\n   * ```ts\n   * const client = new SecretClient(url, credentials);\n   * await client.setSecret(\"MySecretName\", \"ABC123\");\n   *\n   * const deletePoller = await client.beginDeleteSecret(\"MySecretName\");\n   * await deletePoller.pollUntilDone();\n   *\n   * const recoverPoller = await client.beginRecoverDeletedSecret(\"MySecretName\");\n   *\n   * // Serializing the poller\n   * const serialized = recoverPoller.toString();\n   *\n   * // A new poller can be created with:\n   * // const newPoller = await client.beginRecoverDeletedSecret(\"MySecretName\", { resumeFrom: serialized });\n   *\n   * // Waiting until it's done\n   * const deletedSecret = await recoverPoller.pollUntilDone();\n   * console.log(deletedSecret);\n   * ```\n   * Recovers the deleted secret to the latest version.\n   * @param secretName - The name of the deleted secret.\n   * @param options - The optional parameters.\n   */\n  public async beginRecoverDeletedSecret(\n    name: string,\n    options: BeginRecoverDeletedSecretOptions = {}\n  ): Promise<PollerLike<PollOperationState<SecretProperties>, SecretProperties>> {\n    const poller = new RecoverDeletedSecretPoller({\n      name,\n      client: this.client,\n      vaultUrl: this.vaultUrl,\n      ...options,\n      operationOptions: options,\n    });\n\n    // This will initialize the poller's operation (the recovery of the deleted secret).\n    await poller.poll();\n    return poller;\n  }\n\n  /**\n   * Requests that a backup of the specified secret be downloaded to the client. All versions of the\n   * secret will be downloaded. This operation requires the secrets/backup permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let backupResult = await client.backupSecret(\"MySecretName\");\n   * ```\n   * Backs up the specified secret.\n   * @param secretName - The name of the secret.\n   * @param options - The optional parameters.\n   */\n  public backupSecret(\n    secretName: string,\n    options: BackupSecretOptions = {}\n  ): Promise<Uint8Array | undefined> {\n    return tracingClient.withSpan(\"SecretClient.backupSecret\", options, async (updatedOptions) => {\n      const response = await this.client.backupSecret(this.vaultUrl, secretName, updatedOptions);\n\n      return response.value;\n    });\n  }\n\n  /**\n   * Restores a backed up secret, and all its versions, to a vault. This operation requires the\n   * secrets/restore permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * let mySecretBundle = await client.backupSecret(\"MySecretName\");\n   * // ...\n   * await client.restoreSecretBackup(mySecretBundle);\n   * ```\n   * Restores a backed up secret to a vault.\n   * @param secretBundleBackup - The backup blob associated with a secret bundle.\n   * @param options - The optional parameters.\n   */\n  public restoreSecretBackup(\n    secretBundleBackup: Uint8Array,\n    options: RestoreSecretBackupOptions = {}\n  ): Promise<SecretProperties> {\n    return tracingClient.withSpan(\n      \"SecretClient.restoreSecretBackup\",\n      options,\n      async (updatedOptions) => {\n        const response = await this.client.restoreSecret(\n          this.vaultUrl,\n          secretBundleBackup,\n          updatedOptions\n        );\n        return getSecretFromSecretBundle(response).properties;\n      }\n    );\n  }\n\n  /**\n   * Deals with the pagination of {@link listPropertiesOfSecretVersions}.\n   * @param name - The name of the KeyVault Secret.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsPage(\n    secretName: string,\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await tracingClient.withSpan(\n        \"SecretClient.listPropertiesOfSecretVersionsPage\",\n        optionsComplete,\n        (updatedOptions) => this.client.getSecretVersions(this.vaultUrl, secretName, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await tracingClient.withSpan(\n        \"SecretClient.listPropertiesOfSecretVersionsPage\",\n        options,\n        (updatedOptions) =>\n          this.client.getSecretVersionsNext(\n            this.vaultUrl,\n            secretName,\n            continuationState.continuationToken!,\n            updatedOptions\n          )\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecretVersions}.\n   * @param name - The name of the KeyVault Secret.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretVersionsAll(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretVersionsPage(secretName, f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates all versions of the given secret in the vault. The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecretVersions(\"MySecretName\")) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret version: \", secret);\n   * }\n   * ```\n   * @param secretName - Name of the secret to fetch versions for.\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfSecretVersions(\n    secretName: string,\n    options: ListPropertiesOfSecretVersionsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const iter = this.listPropertiesOfSecretVersionsAll(secretName, options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) =>\n        this.listPropertiesOfSecretVersionsPage(secretName, settings, options),\n    };\n  }\n\n  /**\n   * Deals with the pagination of {@link listPropertiesOfSecrets}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsPage(\n    continuationState: PageSettings,\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await tracingClient.withSpan(\n        \"SecretClient.listPropertiesOfSecretsPage\",\n        optionsComplete,\n        (updatedOptions) => this.client.getSecrets(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await tracingClient.withSpan(\n        \"SecretClient.listPropertiesOfSecretsPage\",\n        options,\n        (updatedOptions) =>\n          this.client.getSecretsNext(\n            this.vaultUrl,\n            continuationState.continuationToken!,\n            updatedOptions\n          )\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map(\n          (bundle: SecretBundle | DeletedSecretBundle) =>\n            getSecretFromSecretBundle(bundle).properties\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Deals with the iteration of all the available results of {@link listPropertiesOfSecrets}.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listPropertiesOfSecretsAll(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): AsyncIterableIterator<SecretProperties> {\n    const f = {};\n\n    for await (const page of this.listPropertiesOfSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the latest version of all secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const secretProperties of client.listPropertiesOfSecrets()) {\n   *   const secret = await client.getSecret(secretProperties.name);\n   *   console.log(\"secret: \", secret);\n   * }\n   * ```\n   * List all secrets in the vault.\n   * @param options - The optional parameters.\n   */\n  public listPropertiesOfSecrets(\n    options: ListPropertiesOfSecretsOptions = {}\n  ): PagedAsyncIterableIterator<SecretProperties> {\n    const iter = this.listPropertiesOfSecretsAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listPropertiesOfSecretsPage(settings, options),\n    };\n  }\n\n  /**\n   * Deals with the pagination of {@link listDeletedSecrets}.\n   * @param continuationState - An object that indicates the position of the paginated request.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsPage(\n    continuationState: PageSettings,\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret[]> {\n    if (continuationState.continuationToken == null) {\n      const optionsComplete: GetSecretsOptionalParams = {\n        maxresults: continuationState.maxPageSize,\n        ...options,\n      };\n      const currentSetResponse = await tracingClient.withSpan(\n        \"SecretClient.listDeletedSecretsPage\",\n        optionsComplete,\n        (updatedOptions) => this.client.getDeletedSecrets(this.vaultUrl, updatedOptions)\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle: SecretBundle | DeletedSecretBundle) =>\n          getSecretFromSecretBundle(bundle)\n        );\n      }\n    }\n    while (continuationState.continuationToken) {\n      const currentSetResponse = await tracingClient.withSpan(\n        \"SecretClient.lisDeletedSecretsPage\",\n        options,\n        (updatedOptions) =>\n          this.client.getDeletedSecretsNext(\n            this.vaultUrl,\n            continuationState.continuationToken!,\n            updatedOptions\n          )\n      );\n      continuationState.continuationToken = currentSetResponse.nextLink;\n      if (currentSetResponse.value) {\n        yield currentSetResponse.value.map((bundle: SecretBundle | DeletedSecretBundle) =>\n          getSecretFromSecretBundle(bundle)\n        );\n      } else {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Deals with the iteration of all the available results of {@link listDeletedSecrets}.\n   * @param options - Optional parameters for the underlying HTTP request.\n   */\n  private async *listDeletedSecretsAll(\n    options: ListDeletedSecretsOptions = {}\n  ): AsyncIterableIterator<DeletedSecret> {\n    const f = {};\n\n    for await (const page of this.listDeletedSecretsPage(f, options)) {\n      for (const item of page) {\n        yield item;\n      }\n    }\n  }\n\n  /**\n   * Iterates the deleted secrets in the vault.  The full secret identifier and attributes are provided\n   * in the response. No values are returned for the secrets. This operations requires the secrets/list permission.\n   *\n   * Example usage:\n   * ```ts\n   * let client = new SecretClient(url, credentials);\n   * for await (const deletedSecret of client.listDeletedSecrets()) {\n   *   console.log(\"deleted secret: \", deletedSecret);\n   * }\n   * ```\n   * List all secrets in the vault.\n   * @param options - The optional parameters.\n   */\n  public listDeletedSecrets(\n    options: ListDeletedSecretsOptions = {}\n  ): PagedAsyncIterableIterator<DeletedSecret> {\n    const iter = this.listDeletedSecretsAll(options);\n\n    return {\n      next() {\n        return iter.next();\n      },\n      [Symbol.asyncIterator]() {\n        return this;\n      },\n      byPage: (settings: PageSettings = {}) => this.listDeletedSecretsPage(settings, options),\n    };\n  }\n}\n"]}